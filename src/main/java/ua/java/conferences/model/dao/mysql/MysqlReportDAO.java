package ua.java.conferences.model.dao.mysql;

import lombok.extern.slf4j.Slf4j;
import ua.java.conferences.model.dao.ReportDAO;
import ua.java.conferences.exceptions.DAOException;
import ua.java.conferences.model.entities.*;

import javax.sql.DataSource;
import java.sql.*;
import java.time.LocalDate;
import java.util.*;

import static java.sql.Types.NULL;
import static ua.java.conferences.model.dao.mysql.constants.ReportSQLQueries.*;
import static ua.java.conferences.model.dao.mysql.constants.SQLFields.*;

/**
 * Report DAO class for My SQL database. Matches table 'report' in database.
 *
 * @author Vitalii Kalinchyk
 * @version 1.0
 */
@Slf4j
public class MysqlReportDAO implements ReportDAO {
    /** An instance of datasource to provide connection to database */
    private final DataSource dataSource;

    public MysqlReportDAO(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    /**
     * Inserts new report to database
     * @param report - id will be generated by database. Topic and eventId should be not null. Speaker can be null
     * @throws DAOException is wrapper for SQLException
     */
    @Override
    public void add(Report report) throws DAOException {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(ADD_REPORT)) {
            int k = 0;
            preparedStatement.setString(++k, report.getTopic());
            preparedStatement.setLong(++k, report.getEvent().getId());
            User speaker = report.getSpeaker();
            if (speaker != null) {
                preparedStatement.setLong(++k, speaker.getId());
            } else {
                preparedStatement.setNull(++k, NULL);
            }
            preparedStatement.execute();
        } catch (SQLException e) {
            log.error(String.format("Couldn't add new report %s because of %s", report.getTopic(), e.getMessage()));
            throw new DAOException(e);
        }
    }

    /**
     * Obtains instance of Report from database by id
     * @param id - value of id field in database
     * @return Optional.ofNullable - report is null if there is no report
     * @throws DAOException is wrapper for SQLException
     */
    @Override
    public Optional<Report> getById(long id) throws DAOException {
        Report report = null;
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(GET_REPORT_BY_ID)) {
            int k = 0;
            preparedStatement.setLong(++k, id);
            try (ResultSet resultSet = preparedStatement.executeQuery()) {
                if (resultSet.next()) {
                    report = getReport(resultSet);
                }
            }
        } catch (SQLException e) {
            log.error(String.format("Couldn't find report with id=%d because of %s", id, e.getMessage()));
            throw new DAOException(e);
        }
        return Optional.ofNullable(report);
    }

    /**
     * Obtains list of all reports from database
     * @return reports list
     * @throws DAOException is wrapper for SQLException
     */
    @Override
    public List<Report> getAll() throws DAOException {
        List<Report> reports = new ArrayList<>();
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(GET_REPORTS)) {
            try (ResultSet resultSet = preparedStatement.executeQuery()) {
                while (resultSet.next()) {
                    reports.add(getReport(resultSet));
                }
            }
        } catch (SQLException e) {
            log.error(String.format("Couldn't get list of all reports because of %s", e.getMessage()));
            throw new DAOException(e);
        }
        return reports;
    }

    /**
     * Obtains list of reports by concrete event
     * @param eventId - value of event_id field in database
     * @return reports list that matches demands
     * @throws DAOException is wrapper for SQLException
     */
    @Override
    public List<Report> getEventsReports(long eventId) throws DAOException {
        return getReports(eventId, GET_EVENTS_REPORTS);
    }

    /**
     * Obtains list of reports by concrete speakers
     * @param speakerId - value of user_id field in database
     * @return reports list that matches demands
     * @throws DAOException is wrapper for SQLException
     */
    @Override
    public List<Report> getSpeakersReports(long speakerId) throws DAOException {
        return getReports(speakerId, GET_SPEAKERS_REPORTS);
    }

    private List<Report> getReports(long eventId, String query) throws DAOException {
        List<Report> reports = new ArrayList<>();
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(query)) {
            int k = 0;
            preparedStatement.setLong(++k, eventId);
            try (ResultSet resultSet = preparedStatement.executeQuery()) {
                while (resultSet.next()) {
                    reports.add(getReport(resultSet));
                }
            }
        } catch (SQLException e) {
            log.error(String.format("Couldn't get list of reports because of %s", e.getMessage()));
            throw new DAOException(e);
        }
        return reports;
    }

    /**
     * Updates report
     * @param report should contain id and topic to be updated
     * @throws DAOException is wrapper for SQLException
     */
    @Override
    public void update(Report report) throws DAOException {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(EDIT_REPORT)) {
            int k = 0;
            preparedStatement.setString(++k, report.getTopic());
            preparedStatement.setLong(++k, report.getId());
            preparedStatement.execute();
        } catch (SQLException e) {
            log.error(String.format("Couldn't update report %s because of %s", report.getTopic(), e.getMessage()));
            throw new DAOException(e);
        }
    }

    /**
     * Deletes report record in database
     * @param id - value of id field in database
     * @throws DAOException is wrapper for SQLException
     */
    @Override
    public void delete(long id) throws DAOException {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(DELETE_REPORT)) {
            int k = 0;
            preparedStatement.setLong(++k, id);
            preparedStatement.execute();
        } catch (SQLException e) {
            log.error(String.format("Couldn't delete report with id=%d because of %s", id, e.getMessage()));
            throw new DAOException(e);
        }
    }

    /**
     * Updates user_id field for report
     * @param reportId - value of report_id field in database
     * @param speakerId - value of user_id field in database
     * @throws DAOException is wrapper for SQLException
     */
    @Override
    public boolean setSpeaker(long reportId, long speakerId) throws DAOException {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement =
                     connection.prepareStatement(SET_SPEAKER)) {
            int k = 0;
            preparedStatement.setLong(++k, speakerId);
            preparedStatement.setLong(++k, reportId);
            return preparedStatement.executeUpdate() > 0;
        } catch (SQLException e) {
            log.error(String.format("Couldn't set speaker for report with id=%d because of %s", reportId, e.getMessage()));
            throw new DAOException(e);
        }
    }

    /**
     * Set user_id field as null for report
     * @param reportId - value of report_id field in database
     * @throws DAOException is wrapper for SQLException
     */
    @Override
    public void deleteSpeaker(long reportId) throws DAOException {
        try (Connection connection = dataSource.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(DELETE_SPEAKER)) {
            int k = 0;
            preparedStatement.setLong(++k, reportId);
            preparedStatement.execute();
        } catch (SQLException e) {
            log.error(String.format("Couldn't delete speaker for report with id=%d because of %s", reportId, e.getMessage()));
            throw new DAOException(e);
        }
    }

    private Report getReport(ResultSet resultSet) throws SQLException {
        Event event = getEvent(resultSet);
        User speaker = getSpeaker(resultSet);
        return Report.builder()
                .id(resultSet.getLong(ID))
                .topic(resultSet.getString(TOPIC))
                .event(event)
                .speaker(speaker)
                .build();
    }

    private Event getEvent(ResultSet resultSet) throws SQLException {
        Event event = null;
        long eventId = resultSet.getLong(EVENT_ID);
        if (eventId !=0) {
            event = Event.builder()
                    .id(eventId)
                    .title(resultSet.getString(TITLE))
                    .date(LocalDate.parse(resultSet.getString(DATE)))
                    .location(resultSet.getString(LOCATION))
                    .build();
        }
        return event;
    }

    private static User getSpeaker(ResultSet resultSet) throws SQLException {
        User speaker = null;
        long userId = resultSet.getLong(USER_ID);
        if (userId !=0) {
            speaker = User.builder()
                    .id(userId)
                    .email(resultSet.getString(EMAIL))
                    .name(resultSet.getString(NAME))
                    .surname(resultSet.getString(SURNAME))
                    .build();
        }
        return speaker;
    }
}